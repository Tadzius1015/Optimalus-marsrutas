<!DOCTYPE html>
<html>
<head>
<script src="https://maps.googleapis.com/maps/api/js?v=3.exp&key=AIzaSyA5BAqtLqrAtsuq0Ya3FPJ2qGXmrLiSgvY"></script>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js" type="text/javascript"></script>
<script type="text/javascript">
var map;
var fin;
var nodes = [];
var markers = [];
var durations = [];
var distances = [];
var bestDuration;
var bestRoute = [];
var adresses = [];
var directionsDisplay = null;
var directionsService;
var polylinePath;
var myLocation = false;
var travelType = null;

// Sukuriam google maps zemelapi
function initializeMap() {
    var opts = {
        center: new google.maps.LatLng(54.902434, 23.940171),
        zoom: 13,
        streetViewControl: false,
        mapTypeControl: false,
    };
   
    map = new google.maps.Map(document.getElementById('map-canvas'), opts);
    // Vykdoma paspaudus and zemelapi
    google.maps.event.addListener(map, 'click', function(event) {
        
        // Prideda tiksla i zemelapi
        marker = new google.maps.Marker({position: event.latLng, map: map});
        markers.push(marker);
        
        // Issisaugo lat ir lng
        nodes.push(event.latLng);
        // Padidina keliones tikslu kieki
        $('#destinations-count').html(nodes.length);
    });
    // Prideda mygtuka kuris i marsruta itraukia dabartine vartotojo vieta
    var myLocationDiv = document.createElement('div');
    new getMyLocation(myLocationDiv, map);
    map.controls[google.maps.ControlPosition.TOP_RIGHT].push(myLocationDiv);

    function getMyLocation(myLocationDiv, map) {
        var myLocationBtn = document.createElement('button');
        myLocationBtn.innerHTML = 'Mano buvimo vieta';
        myLocationBtn.className = 'large-btn';
        myLocationBtn.style.margin = '5px';
        myLocationBtn.style.opacity = '0.95';
        myLocationBtn.style.borderRadius = '3px';
        myLocationDiv.appendChild(myLocationBtn);

        google.maps.event.addDomListener(myLocationBtn, 'click', function () {
            navigator.geolocation.getCurrentPosition(function (success) {
                if(!myLocation){
                    var pos = {
                        lat: success.coords.latitude,
                        lng: success.coords.longitude
                    };
                    nodes.push(pos);
                    $('#destinations-count').html(nodes.length);
                    // Prideda tiksla i zemelapi
                    marker = new google.maps.Marker({ position: pos, map: map });
                    markers.push(marker);
                    map.setCenter(new google.maps.LatLng(pos.lat, pos.lng));
                    map.setZoom(13);
                    myLocation = true;
                }
                else {
                    window.alert("Buvimo vieta jau pažymėta!");
                }
            });
        });
    }
}
// Gauna keliones laikus ir atstumus tarp tikslu
function getDurations(origin, destination) {
    var service = new google.maps.DistanceMatrixService();
    var d = $.Deferred();
    service.getDistanceMatrix({
        origins: origin,
        destinations: destination,
        travelMode: 'DRIVING',
    },
    function (response, status) {
        if (status != google.maps.DistanceMatrixStatus.OK) {
            d.reject(status);
        } else {
            d.resolve(response);
        }
    });
    return d.promise();
}
function findDurations() {
    getDurations(nodes, nodes)
        .done(function (response) {
            var origins = response.originAddresses;
            for (var i = 0; i < origins.length; i++) {
                if (origins[i] != undefined)
                    adresses[i] = origins[i];
            }
            var nodeDistanceData;
            for (originNodeIndex in response.rows) {
                nodeDistanceData = response.rows[originNodeIndex].elements;
                durations[originNodeIndex] = [];
                distances[originNodeIndex] = [];
                for (destinationNodeIndex in nodeDistanceData) {
                    durations[originNodeIndex][destinationNodeIndex] = nodeDistanceData[destinationNodeIndex].duration.value;
                    distances[originNodeIndex][destinationNodeIndex] = nodeDistanceData[destinationNodeIndex].distance.value;
                }
            }
            gg();
        })
    .fail(function (status) {
        output3.innerHTML = "Ivyko klaida gaunant informacija is google maps ";
    })
}

//Apskaiciuoja pateikto marsruto ilgi pagal eiles tvarka
function calcDistance(points) {
    var sum = 0;
    var prev = 0;
    points.splice(0, 1);
    for (var i = 0; i < points.length; i++) {
        var d = distances[prev][points[i]];
        prev = points[i];
        sum += d;
    }
    points.unshift(0);
    return sum;
}
//Apskaiciuoja pateikto marsruto laika pagal eiles tvarka
function calcDuration(points) {
    var sum = 0;
    var prev = 0;
    points.splice(0, 1);
    for (var i = 0; i < points.length; i++) {
        var d = durations[prev][points[i]];
        prev = points[i];
        sum += d;
    }
    points.unshift(0);
    return sum;
}
//Randa trumpiausia is sugeneruotu marsrutu    
function findShortest(perm) {
    bestDuration = Infinity;
    var d;
    for (var i = 0; i < perm.length; i++) {
        d = calcDuration(perm[i]);
        if (d < bestDuration) {
            bestDuration = d;
            bestRoute = perm[i];
        }
    }
    return bestRoute;
}

function printRoute(best) {
    outputDiv.innerHTML += adresses[0] + '<br>';
    for (var i = 1; i < best.length; i++) {
        outputDiv.innerHTML += adresses[best[i]] + '<br>';
    }
}
//Ekrane isspausdina
function showRoute() {
    outputDiv.textContent = "";

    travelType = $('#travel-type').val();
    findDurations();  
}
    
function gg() {
    if (nodes.length < 8) {
        var perm;
        var ind = Array.from(Array(nodes.length).keys());
        console.log(travelType);
        perm = generateCityRoutes(ind);
        t = true;
        var best = findShortest(perm);
        printRoute(best);
        poly(best);
    }
    else {
        if (directionsDisplay != null) {
            directionsDisplay.setMap(null);
            directionsDisplay = null;
        }

        var pop = new ga.population();
        pop.initialize(nodes.length);
        var best = pop.getFittest().chromosome.slice();
        ga.evolvePopulation(pop, function (update) {

            var route = update.population.getFittest().chromosome;
            for (var i = 0; i < route.length; i++) {
                best[i] = route[i];
            }
        });
        printRoute(best);
        poly(best);
    }
    bestDuration = calcDuration(best);
    bestDistance = calcDistance(best);
    //console.log("Apytikslis keliones laikas: " + ((bestDuration / 60)+((bestDuration%60)/100*60)) + " min");
    //console.log("Apytikslis keliones atstumas: " + (bestDistance / 1000).toFixed(1) + " km");
    var temp = bestDuration / 60;
    outputDiv.innerHTML += "" + '<br>';
    outputDiv.innerHTML += "Apytikslis keliones laikas: " + Math.floor(temp) + " min "+ ((temp.toFixed(2)-Math.floor(temp))*60).toFixed(0) + " s" + '<br>';
    outputDiv.innerHTML += "Apytikslis keliones atstumas: " + (bestDistance / 1000).toFixed(1) + " km" + '<br>';
}

// Panaikina zymeklius ir kelius
function clearMapMarkers() {
    for (index in markers) {
        markers[index].setMap(null);
    }
    nodes = [];
    if (polylinePath != undefined) {
        polylinePath.setMap(null);
    }
    markers = [];
}
// Panaikina marsrutus, jei rodomi
function clearDirections() {
    // Jeigu rodomas marsrutas, jį panaikina
    if (directionsDisplay != null) {
        directionsDisplay.setMap(null);
        directionsDisplay = null;
    }
}
// Isvalo zemelapi
function clearMap() {
    clearMapMarkers();
    clearDirections();
    outputDiv.textContent = "";
    output3.textContent = "";
    route = [];
    bestDuration = Infinity;
    bestRoute = [];
    adresses = [];
    myLocation = false;
    $('#destinations-count').html('0');
}
//Generuoja galimus aibes isdestymo variantus
function generatePermutations(Arr) {
    var permutations = [];
    var A = Arr.slice();

    function swap(a, b) {
        var tmp = A[a];
        A[a] = A[b];
        A[b] = tmp;
    }

    function generate(n, A) {
        if (n == 1) {
            permutations.push(A.slice());
        } else {
            for (var i = 0; i <= n - 1; i++) {
                generate(n - 1, A);
                swap(n % 2 === 0 ? i : 0, n - 1);
            }
        }
    }
    generate(A.length, A);
    return permutations;
}
//Generuoja visus marsrutus, kuriuos galima sudaryti is aibes
function generateCityRoutes(cities) {
    var pems = null;
    if (travelType == "GR")
        pems = generatePermutations(cities.slice(1));
    else if (travelType == "NGR")
        pems = generatePermutations(cities.slice(1,cities.length-1));
    for (var i = 0; i < pems.length; i++) {
        pems[i].unshift(cities[0]);
        if (travelType == "GR") {          
            pems[i].push(cities[0]);
        }
        else if (travelType == "NGR") {
            pems[i].push(cities[cities.length]);
        }
    }
    return pems;
}

//sukuria linijas marsrutui atvaizduoti
function poly(best) {
    directionsService = new google.maps.DirectionsService();
    directionsDisplay = new google.maps.DirectionsRenderer();
    directionsDisplay.setMap(map);
    var waypts = [];
    if (travelType == "GR") {
        for (var i = 0; i < best.length - 1; i++) {
            waypts.push({
                location: nodes[best[i]],
                stopover: true
            });
        }
        // Pridedamas marsrutas i zemelapi
        var request = {
            origin: nodes[0],
            destination: nodes[0],
            waypoints: waypts,
            travelMode: 'DRIVING',
        };
        directionsService.route(request, function (response, status) {
            if (status == google.maps.DirectionsStatus.OK) {
                directionsDisplay.setDirections(response);
            }
            clearMapMarkers();
        });
    }
    else if (travelType == "NGR") {
        for (var i = 0; i < best.length; i++) {
            waypts.push({
                location: nodes[best[i]],
                stopover: true
            });
        }
        // Pridedamas marsrutas i zemelapi
        var request = {
            origin: nodes[0],
            destination: nodes[nodes.length],
            waypoints: waypts,
            travelMode: 'DRIVING',
        };
        directionsService.route(request, function (response, status) {
            if (status == google.maps.DirectionsStatus.OK) {
                directionsDisplay.setDirections(response);
            }
            clearMapMarkers();
        });
    }
    
}
google.maps.event.addDomListener(window, 'load', initializeMap);

// Genetinio algoritmo kodas
var ga = {
    // algoritmo konstantos
    "crossoverRate": 0.5,
    "mutationRate": 0.1,
    "populationSize": 50,
    "tournamentSize": 5,
    "elitism": true,
    "maxGenerations": 100,
    "tickerSpeed": 60,

    // Evoliucionuoja populiacija
    "evolvePopulation": function (population, generationCallBack, completeCallBack) {
        var generation = 1;
        var evolveInterval = setInterval(function () {
            if (generationCallBack != undefined) {
                generationCallBack({
                    population: population,
                    generation: generation,
                });
            }
            population = population.crossover();
            //population.mutate();
            generation++;

            // Tikrina ar praejo pakankamai kartu
            if (generation > ga.maxGenerations) {
                clearInterval(evolveInterval);

                if (completeCallBack != undefined) {
                    completeCallBack({
                        population: population,
                        generation: generation,
                    });
                }
            }
        }, ga.tickerSpeed);
    },
    // Populiacijos klase
    "population": function () {
        // Populiacija - individu masyvas
        this.individuals = [];

        // Pradine populiacija su atsitiktiniais individais
        this.initialize = function (chromosomeLength) {
            this.individuals = [];

            for (var i = 0; i < ga.populationSize; i++) {
                var newIndividual = new ga.individual(chromosomeLength);
                newIndividual.initialize();
                this.individuals.push(newIndividual);
            }
        };

        // Mutuoja populiacija
        this.mutate = function () {
            var fittestIndex = this.getFittestIndex();
            for (index in this.individuals) {
                // Nemutuoti geriausio individo
                if (ga.elitism != true || index != fittestIndex) {
                    this.individuals[index].mutate();
                }
            }
        };
        // Pritaiko kryzminima ir grazina nauja karta
        this.crossover = function () {
            // nauja karta
            var newPopulation = new ga.population();

            var fittestIndex = this.getFittestIndex();
            for (index in this.individuals) {
                // Paima geriausia individa ir prideda ji i nauja karta
                if (ga.elitism == true && index == fittestIndex) {
                    // Replicate individual
                    var eliteIndividual = new ga.individual(this.individuals[index].chromosomeLength);
                    eliteIndividual.setChromosome(this.individuals[index].chromosome.slice());
                    newPopulation.addIndividual(eliteIndividual);
                } else {
                    // Parenka su kuo maisys
                    var parent = this.tournamentSelection();
                    // Ir pritaiko kryzminima
                    this.individuals[index].crossover(parent, newPopulation);
                }
            }

            return newPopulation;
        };
        // Prideda individa i populiacija
        this.addIndividual = function (individual) {
            this.individuals.push(individual);
        };
        // Isrenka individa naudojant turnyro selekcija
        this.tournamentSelection = function () {
            for (var i = 0; i < this.individuals.length-1; i++) {
                var randomIndex = Math.floor(Math.random() * this.individuals.length);
                var tempIndividual = this.individuals[randomIndex];
                this.individuals[randomIndex] = this.individuals[i];
                this.individuals[i] = tempIndividual;
            }
            var tournamentPopulation = new ga.population();
            for (var i = 0; i < ga.tournamentSize; i++) {

                tournamentPopulation.addIndividual(this.individuals[i]);
            }
            var fittest = tournamentPopulation.getFittest();
            return fittest;
        };

        // Grazina geriausio individo indeksa populiacijoje
        this.getFittestIndex = function () {
            var fittestIndex = 0;
            for (var i = 1; i < this.individuals.length; i++) {
                if (this.individuals[i].calcFitness() > this.individuals[fittestIndex].calcFitness()){
                    fittestIndex = i;
                }
            }
            return fittestIndex;
        };
        this.getFittest = function () {
            return this.individuals[this.getFittestIndex()];
        };
    },
    // Individo klase
    "individual": function (chromosomeLength) {
        this.chromosomeLength = chromosomeLength;
        this.fitness = null;
        this.chromosome = [];
        // Sukuriamas atsitiktinis individas(marsrutas)
        this.initialize = function () {
            this.chromosome = [];
            for (var i = 0; i < this.chromosomeLength-1; i++) {
                this.chromosome.push(i+1);

            }
            for (var i = 0; i < this.chromosomeLength-1; i++) {
                var randomIndex = Math.floor(Math.random()*(this.chromosome.length - 1));
                var tempNode = this.chromosome[randomIndex];
                this.chromosome[randomIndex] = this.chromosome[i];
                this.chromosome[i] = tempNode;
            }
            this.chromosome.unshift(0);
            this.chromosome.push(0);
        };

        // Nustato individo chromosomas (marsruto eiliskuma)
        this.setChromosome = function (chromosome) {
            this.chromosome = chromosome;
        };

        // Mutuoja individa
        this.mutate = function () {
            this.fitness = null;
            this.chromosome.splice(this.chromosomeLength - 1, 1);
            this.chromosome.shift();

            // Daromi atsitiktiniai pakeitimai
            for (index in this.chromosome) {
                if (ga.mutationRate > Math.random()) {
                    var randomIndex = Math.floor(Math.random() * this.chromosomeLength-1);
                    var tempNode = this.chromosome[randomIndex];
                    this.chromosome[randomIndex] = this.chromosome[index];
                    this.chromosome[index] = tempNode;
                }
            }
            this.chromosome.unshift(0);
            this.chromosome.push(0);
        };

        // Grazina individo keliones trukme
        this.getDistance = function () {
            var totalDistance = 0;
            for (index in this.chromosome) {
                var startNode = this.chromosome[index];
                var endNode = this.chromosome[0];
                if ((parseInt(index) + 1) < this.chromosome.length) {
                    endNode = this.chromosome[(parseInt(index) + 1)];
                }
                totalDistance += durations[startNode][endNode];
            }

            totalDistance += durations[startNode][endNode];

            return totalDistance;
        };
        // Apskaiciuojamas individo tinkamumas
        this.calcFitness = function () {
            if (this.fitness != null) {
                return this.fitness;
            }

            var totalDistance = this.getDistance();
            this.fitness = 1 / totalDistance;
            return this.fitness;
        };
        //Pritaiko kryzminima individui ir nurodytam partneriui ir rezultatus sudeda i nauja populiacija
        this.crossover = function (individual, offspringPopulation) {
            var offspringChromosome = [];
            this.chromosome.splice(this.chromosomeLength - 1, 1);
            this.chromosome.shift();
            // Atsitiktinai atrenkama ka prideti i nauja populiacija
            var startPos = Math.floor(this.chromosome.length * Math.random());
            var endPos = Math.floor(this.chromosome.length * Math.random());
            var i = startPos;
            while (i != endPos) {
                offspringChromosome[i] = individual.chromosome[i];
                i++
                if (i >= this.chromosome.length) {
                    i = 0;
                }
            }
            this.chromosome.unshift(0);
            this.chromosome.push(0);
            // Pridedama likusi informacija 
            for (parentIndex in individual.chromosome) {
                var node = individual.chromosome[parentIndex];
                var nodeFound = false;
                for (offspringIndex in offspringChromosome) {
                    if (offspringChromosome[offspringIndex] == node) {
                        nodeFound = true;
                        break;
                    }
                }
                if (nodeFound == false) {
                    for (var offspringIndex = 0; offspringIndex < individual.chromosome.length; offspringIndex++) {
                        if (offspringChromosome[offspringIndex] == undefined) {
                            offspringChromosome[offspringIndex] = node;
                            break;
                        }
                    }
                }
            }
            // Naujam individui pridedamos atrinktos chromosomos ir jis pridedamas prie naujos populiacijos 
            var offspring = new ga.individual(this.chromosomeLength);
            offspring.setChromosome(offspringChromosome);
            offspringPopulation.addIndividual(offspring);
        };
    },
};

</script>
</head>
<body>
<div>
  <div id="map-canvas" style="width:660px; height:560px;"></div>
  <div>
    <table>
        <tr>
            <td>Norimu aplankyti vietu skaicius: </td>
            <td id="destinations-count">0</td>
        </tr>
        <tr>
            <td>Kelionės tipas</td>
            <td>
                <select id="travel-type">
                    <option value="GR">Grįžtama į pradžią</option>
                    <option value="NGR">Važiojama į paskutinį pažymėtą</option>
                </select>
            </td>
            </tr>
        <tr>
            <td colspan="2"><button onclick="showRoute()">Rasti maršrutą</button> <button class="btn" onclick="clearMap()">Išvalyti žemėlapį</button></td>
        </tr>
    </table>
  </div>
</div>
    <div id="outputDiv"></div>
    <div id="output3"> </div>
</body>
</html>
